//1094, 막대기 20240805 
//Silver 5
#include<iostream>
#include<cmath>

using namespace std;

int main()
{
	int X, sum = 0, cnt = 0;
	cin >> X;


	while (sum != X)
	{
		for (int i = 6; i >= 0; i--)
		{
			if (X - sum >= pow(2, i))
			{
				sum += pow(2, i);
				cnt++;
				break;
			}
		}
	}
	cout << cnt;
}
/*
64, 32, 16 , 8, 4, 2, 1
1-1~2 과정에서 조건에 따라 중복되는 수는 절반으로 잘라지거나 버려진다는 것을 알 수 있다.
즉, 모든 수는 위 수의 중복되지 않는 합으로 구해질 수 있다. 최대로 필요한 막대의 개수는 6개이고, (64보다 큰 것은 생각하지 않으므로)
X보다 작거나 같은 2의 거듭제곱수 중 가장 큰 K를 더하고, X-K보다 작거나 같은 2의 거듭제곱수 중 가장 큰 L을 더하고..를 반복하면 되겠다.
다소 복잡하게 표현되었지만, 2의 거듭제곱수의 합으로 모든 수를 구할 수 있음을 이용하는 것이 문제의 본질이다.

+문제에 따라 X를 구하는 과정을 생각해보면, 거듭제곱의 합을 이용해 범위를 줄여나가는 방식으로 X를 탐색해가는 것을 알 수 있다. 아래 방식대로도 구현은 가능하겠다.
- X < 가장 작은 막대를 제외한 합
- 가장 작은 막대를 제외한 합 < X < 모든 막대의 합
의 두 가지 경우로 범위를 좁혀나간다.
*/