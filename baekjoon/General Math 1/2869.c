//2869, 달팽이는 올라가고 싶다 20240623
#include<stdio.h>
int main()
{
	int A, B, V, day=0, mod, div;
	scanf("%d %d %d", &A, &B, &V); //B < A인 점을 참고하자.

	V -= A; //역순으로, 목표 높이 V에서 하루에 올라가는 A를 뺀다. A만큼 올라갔을 때 목표에 도달하면 B만큼 내려가지 않아도 되기 때문.
	day++;//1일 추가

	div = V / (A - B); //남은 V에 대해 A-B(하루에 움직이는 거리)로 몫연산
	mod = V % (A - B); //남은 V에 대해 A-B(하루에 움직이는 거리)로 나머지연산
	day+=div; //몫 값을 day에 추가
	
	if (mod != 0) //나머지가 존재하는 경우 추가로 이동해야 하며, 이때 A-B로 나머지 연산했으니, 1일만 추가하면 된다.
	{
		day++;
	}
	printf("%d", day);
} 
/*
이 문제는 아래와 같은 반복문을 사용하면 간단하게 풀 수 있는 문제이다.
H=0;
while(1)
{
	day++;
	H += A;
	if(H >= V) break;
	H -= B;
}
그러나, 시간 제한이 0.25초로 촉박한 데 반해 A, B, V의 최댓값은 1,000,000,000이므로, 반복문을 이용한다면
시간이 초과될 수 밖에 없다. 즉 반복문을 사용하지 않고 결과값을 구해야하고, 이를 위해서는 모든 값에 대해 일반화될 수 있는 수식이 필요하다.
시간은 곧 효율성(시간 복잡도)과 직결되는 대상이므로, 잘 짜는 것도 중요하지만, 효율적으로 짜는 것 역시 중요하다는 점을 기억하자.
*/