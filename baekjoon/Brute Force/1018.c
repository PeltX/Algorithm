//1018, 체스판 다시 칠하기 20240707
#include<stdio.h>
int main()
{
	int N, M, i, j, k, l, x, y, tmp[2000], min, cnt, wcnt, bcnt, tarr[8][8], a = 0, b = 0, t = 0;
	char arr[51][51];

	for (i = 0; i < 2000; i++)
		tmp[i] = -1;

	scanf("%d %d", &N, &M);

	//체스판 입력
	for (i = 0; i < N; i++)
		scanf("%s", arr[i]);

	//브루트 포스(체스판 자르기) - 8X8 크기의 보드를 만들 수 있는 모든 경우의 수를 구한다. 최대 50X50크기의 배열이 저장되므로, 43x43개의 체스판이 만들어질 수 있다. 
	for (y = 0; y < N - 7; y++)
	{
		for (x = 0; x < M - 7; x++) //[0][0]에서부터 8X8 보드가 만들어지는 경우의 수 탐색
		{
			wcnt = 0;
			bcnt = 0;

			//자른 보드를 저장할 임시배열 만들기. 칠하는 개수를 구하는 과정을 보다 직관적으로 처리하기 위해 사용했다.
			for (i = y; i < y + 8; i++) //1행 ~ 8행
			{
				for (j = x; j < x + 8; j++) //각 행의 1열 ~ 8열
				{
					tarr[a][b] = arr[i][j];
					b++;
				}
				a++;
				b = 0;
			}
			a = 0;

			//첫 칸을 흰색으로 잡는 경우
			for (k = 1; k <= 4; k++)
			{
				//보드 확인 
				if (tarr[2 * k - 2][0] == 'B') //짝수 행
					wcnt++;
				for (l = 1; l <= 7; l++) //행의 첫 문자는 W이고, 1,3,5,7행의 첫 문자는 B, 2,4,6행의 첫 문자는 W
				{
					if (l % 2 == 1 && tarr[2 * k - 2][l] == 'W')
						wcnt++;
					else if (l % 2 == 0 && tarr[2 * k - 2][l] == 'B')
						wcnt++;	
				}
				
				if (tarr[2 * k - 1][0] == 'W') //홀수 행
					wcnt++;
				for (l = 1; l <= 7; l++) //행의 첫 문자는 B이고, 1,3,5,7행의 첫 문자는 W, 2,4,6행의 첫 문자는 B
				{
					if (l % 2 == 1 && tarr[2 * k - 1][l] == 'B')
						wcnt++;
					else if (l % 2 == 0 && tarr[2 * k - 1][l] == 'W')
						wcnt++;
				}
			}

			//첫 칸을 검은색으로 잡는 경우
			for (k = 1; k <= 4; k++)
			{
				//보드 확인
				if (tarr[2 * k - 2][0] == 'W') //짝수 행
					bcnt++;
				for (l = 1; l <= 7; l++) //행의 첫 문자는 B이고, 1,3,5,7행의 첫 문자는 W, 2,4,6행의 첫 문자는 B
				{
					if (l % 2 == 1 && tarr[2 * k - 2][l] == 'B')
						bcnt++;
					else if (l % 2 == 0 && tarr[2 * k - 2][l] == 'W')
						bcnt++;
				}

				if (tarr[2 * k - 1][0] == 'B') //홀수 행
					bcnt++;
				for (l = 1; l <= 7; l++) //행의 첫 문자는 W이고, 1,3,5,7행의 첫 문자는 B, 2,4,6행의 첫 문자는 W
				{
					if (l % 2 == 1 && tarr[2 * k - 1][l] == 'W')
						bcnt++;
					else if (l % 2 == 0 && tarr[2 * k - 1][l] == 'B')
						bcnt++;
				}
			}
			cnt = (wcnt < bcnt) ? wcnt : bcnt; //wcnt와 bcnt 중 더 작은 값을 저장
			tmp[t] = cnt; //저장소에 케이스의 결과값을 저장
			t++;
		}
	}
	min = tmp[0];
	//tmp의 최솟값 탐색
	for (i = 1; i < 2000; i++) 
	{
		if (tmp[i] == -1)
			break;
		min = (min < tmp[i]) ? min : tmp[i];
	}
	printf("%d", min);
}
/*idea
8X8 이상의 보드에서 8X8 크기의 체스판을 잘라내야 하므로, 브루트 포스를 이용하면 모든 경우의 수를 알 수 있지 않을까?
잘라진 모든 경우의 체스판에 대해 칠해야하는 개수를 구하고, 칠하는 개수에 대한 배열에 저장해 그 중 최솟값을 골라내면 될 것 같다.
보드의 최대 크기는 50X50이니, 나올 수 있는 최대 경우의 수는 그렇게 크지 않을 것이다.
12345678
23456789
...
43 44 45 46 47 48 49 50 43개.
아래로도 43개.
최대 경우의 수는 43*43이다.

마지막으로, 조건에 대해서
맨 왼쪽 위 칸이 W인 경우
맨 왼쪽 위 칸이 B인 경우
로 나누어 생각해보자.

즉 구해야하는 것을 크게 나누어보면
1. 주어진 N, M에 대해 모든 경우의 8X8 체스판을 구하는 코드
ㄴ 각 케이스의 체스판을 저장할 임시배열을 만들어 직관적으로 처리하고자 한다.
2. 체스판을 칠해야하는 개수를 구하는 코드
ㄴ 맨 왼쪽 위 칸의 문자에 따라 한 케이스에서 개수는 달라질 수 있다.
3. 개수의 최솟값을 구하는 코드
이다.
*/

/*
기준 인덱스에 저장된 값과 인접한 인덱스에 저장된 값을 비교하는 방식으로도 풀 수 있을 듯하다.
이 경우, 기준값을 바꾸는 경우, 인접값을 바꾸는 경우로 분류할 수 있다. 본 풀이처럼 첫 행의 첫 항이 W인 경우, B인 경우로 구분되기는 하지만,
본 풀이의 경우 처음부터 첫 항 값을 잡고 시작한 반면, 이 풀이에서는 첫 항의 초기값이 무엇이었는지와는 관련 없이, 변경했을 때의 결과값이 W인 경우, B인 경우이다.
또, 기준값과 인접값을 비교하는 과정에서 기준값 또는 인접값의 변경이 일어나므로, 잘라낸 체스판을 저장할 두 개의 임시배열이 필요하다.
본 배열의 값을 변경해버리면 조건에 영향을 주게 되므로..
*/