//Counting Sort, 카운팅 정렬
#include<iostream>

void Counting(int arr[], int res[], int N) {
	int i, cnt[101] = { 0 };

	for (i = 0; i < N; i++) //입력받은 숫자에 해당하는 인덱스의 카운트 증가
		cnt[arr[i]]++;

	for (i = 2; i < 101; i++) //카운팅 배열의 누적합 계산. 이 시점에서 정렬된 상태로 봐도 좋다.
		cnt[i] += cnt[i - 1];

	for (i = N-1; i >= 0; i--) //arr의 마지막 항~첫 항까지
	{
		res[cnt[arr[i]] - 1] = arr[i]; //res 배열의 각 인덱스에 정렬된 arr 배열의 값 저장.
		cnt[arr[i]]--;
	}
}

int main()
{
	int arr[10] = { 1, 3, 2, 4, 3, 1, 1, 2, 5, 4 }, brr[5] = { 1,5,4,3,2 }, cnt[101] = { 0 }, res[10];
	int i;

	printf("-ARR SORT-\n");
	Counting(arr, res, 10);
	for (i = 0; i < 10; i++)
		printf("%d\n", res[i]);

	printf("-BRR SORT-\n");
	Counting(brr, res, 5);
	for (i = 0; i < 5; i++)
		printf("%d\n", res[i]);
}

/*
카운팅 정렬의 아이디어를 일부 활용하는 문제다. 수의 입력 범위가 작은 경우, 입력받은 숫자를 인덱스로 하는 배열의 카운트를 증가시킨다.
이후 arr[0]부터 arr[max-1]까지 값을 조사해, 각 인덱스의 값이 0이 될 때까지 저장된 카운트를 감소시키며 인덱스에 해당하는 숫자를 출력한다.
문제에서는 자연수 1~10000 범위로 입력을 제한햇으므로, arr[0]에 1의 카운트가 저장됨을 기억하자.
실제 카운팅 정렬은 입력받은 숫자를 인덱스로 하는 배열의 카운트를 증가시킨 후, 각 배열의 값을 누적합으로 변환하는 과정을 거친다.
각 누적합은 각각의 숫자가 마지막으로 저장될 인덱스를 의미하며, 한 숫자를 저장한 후 해당 숫자의 카운팅 배열값을 1 감소시키면서 새로운 배열에 정렬 결과를 저장한다.
*/